<h1>Stack</h1>
<h2>리스트를 사용하여 스택을 구현</h2>
<p>
    장점 : 구현이 매우 용이
    <br>
    단점 : 리스트의 크기를 변경하는 작업은 내부적으로 큰 overhead 발생 작업으로 많은 시간 소요
</p>
<h2>해결방법</h2>
<p>
    <ul>
    <li>리스트의 크기를 배열처럼 정해놓고 사용하는 방법</li>
    <li>동적 연결 리스트를 사용하여 저장소를 동적으로 할당하여 스택을 구현하는 방법</li>
    </ul>
    장점 : 구현이 용이
    <br>
    단점 : 리스트로 구현하는 것보다 복잡
    <br>
    일반적으로 메인 함수 내에서 여러가지 함수를 호출 했을 때 실행되는 과정 또한 스택의 원리와 동일.
    <br>
    재귀함수도 유사하게 생각할 수 있다.
</p>
<h2>memoization</h2>
<p>
memoization 방법을 적용한 알고리즘<br>
예시 ) 피보나치 수열을 구하는 알고리즘에서 기존에 계산했던 값을 다시 구하는 것이라면,
<br>미리 저장해놓은 값읋 보여준다.
<br>
동적계획법(DP)의 핵심
</p>
<h2>동적계획법</h2>
<p>
그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
<br>
입력크기가 작은 단계부터 해결하고 이를 이용하여 큰 크기의 부분 문제를 해결.
<h3>피보나치 수열에 DP적용하기</h3>
<ol>
<li>문제를 부분 문제로 분할</li>
<li>부분 문제로 분할한 이후 가장 작은 단위의 문제부터 해결</li>
<li>그 결과를 테이블에 저장, 이를 이용해 상위 문제의 해 구함</li>
</ol>
</p>

<h2>DFS</h2>
<p>
1. 시작 정점 v를 방문.
<br>
2-1. 방문하지 않은 정점 w가 있다면 v를 스택에 push하고 w 방문.
<br>
w를 v로 하여 1번 반복.

2-2. 방문하지 않은 정점이 없다면 탐색의 방향을 바꾸기 위해 스택을 pop하여 가장 마지막 방문 정점 v로 하여 1번 반복.
</p>

<h1>Queue</h1>